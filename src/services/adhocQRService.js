/**
 * Adhoc QR Service
 * Handles logging and retrieval of Quick QR codes generated by agents
 * Stores QR generation history in nic_adhoc_qr_codes table
 */

const XANO_BASE_URL = import.meta.env.VITE_XANO_BASE_URL
const API_KEY = import.meta.env.VITE_XANO_ADHOC_QR_API || 'adhoc_qr_api'
const ENDPOINT = `${XANO_BASE_URL}/api:${API_KEY}/nic_adhoc_qr_codes`

class AdhocQRService {
  /**
   * Log QR code generation to database
   * @param {Object} qrData - QR generation data
   * @returns {Promise<Object>} Created record
   */
  async logQRGeneration(qrData) {
    try {
      const response = await fetch(ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(qrData),
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.message || 'Failed to log QR generation')
      }

      const data = await response.json()
      console.log('âœ“ QR generation logged:', data.id)
      return data
    } catch (error) {
      console.error('Error logging QR generation:', error)
      throw error
    }
  }

  /**
   * Get QR codes for current agent
   * @param {number} agentId - Agent ID
   * @param {Object} filters - Optional filters
   * @returns {Promise<Array>} Array of QR records
   */
  async getMyQRCodes(agentId, filters = {}) {
    try {
      const params = new URLSearchParams()
      params.append('agent_id', agentId)
      
      if (filters.qr_type) params.append('qr_type', filters.qr_type)
      if (filters.status) params.append('status', filters.status)
      if (filters.line_of_business) params.append('line_of_business', filters.line_of_business)
      
      const url = `${ENDPOINT}?${params}`

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      })

      if (!response.ok) {
        throw new Error('Failed to fetch QR codes')
      }

      const data = await response.json()
      
      // Filter by agent_id on client side if Xano filtering doesn't work
      const filtered = Array.isArray(data) 
        ? data.filter(qr => qr.agent_id === agentId || qr.agent_id === parseInt(agentId))
        : []
      
      return filtered.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
    } catch (error) {
      console.error('Error fetching QR codes:', error)
      return []
    }
  }

  /**
   * Get all QR codes (admin only)
   * @param {Object} filters - Optional filters
   * @returns {Promise<Array>} Array of QR records
   */
  async getAllQRCodes(filters = {}) {
    try {
      const params = new URLSearchParams()
      
      if (filters.agent_id) params.append('agent_id', filters.agent_id)
      if (filters.qr_type) params.append('qr_type', filters.qr_type)
      if (filters.status) params.append('status', filters.status)
      if (filters.line_of_business) params.append('line_of_business', filters.line_of_business)
      if (filters.branch_id) params.append('branch_id', filters.branch_id)
      
      const url = params.toString() ? `${ENDPOINT}?${params}` : ENDPOINT

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      })

      if (!response.ok) {
        throw new Error('Failed to fetch QR codes')
      }

      const data = await response.json()
      return Array.isArray(data) 
        ? data.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
        : []
    } catch (error) {
      console.error('Error fetching all QR codes:', error)
      return []
    }
  }

  /**
   * Get single QR code by ID
   * @param {number} qrId - QR record ID
   * @returns {Promise<Object>} QR record
   */
  async getQRById(qrId) {
    try {
      const response = await fetch(`${ENDPOINT}/${qrId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      })

      if (!response.ok) {
        throw new Error('Failed to fetch QR code')
      }

      return await response.json()
    } catch (error) {
      console.error('Error fetching QR code:', error)
      throw error
    }
  }

  /**
   * Update QR code status
   * @param {number} qrId - QR record ID
   * @param {string} status - New status
   * @returns {Promise<Object>} Updated record
   */
  async updateQRStatus(qrId, status) {
    try {
      const response = await fetch(`${ENDPOINT}/${qrId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ status }),
      })

      if (!response.ok) {
        throw new Error('Failed to update QR status')
      }

      return await response.json()
    } catch (error) {
      console.error('Error updating QR status:', error)
      throw error
    }
  }

  /**
   * Mark email as sent
   * @param {number} qrId - QR record ID
   * @returns {Promise<Object>} Updated record
   */
  async markEmailSent(qrId) {
    try {
      const response = await fetch(`${ENDPOINT}/${qrId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email_sent: true,
          email_sent_at: new Date().toISOString(),
        }),
      })

      if (!response.ok) {
        throw new Error('Failed to mark email as sent')
      }

      return await response.json()
    } catch (error) {
      console.error('Error marking email as sent:', error)
      throw error
    }
  }

  /**
   * Search QR codes by reference number or customer name
   * @param {string} searchTerm - Search term
   * @param {number} agentId - Agent ID (optional, for filtering)
   * @returns {Promise<Array>} Matching QR records
   */
  async searchQRCodes(searchTerm, agentId = null) {
    try {
      // Fetch all QR codes (or agent's QR codes)
      const qrCodes = agentId 
        ? await this.getMyQRCodes(agentId)
        : await this.getAllQRCodes()
      
      // Filter by search term
      const searchLower = searchTerm.toLowerCase()
      return qrCodes.filter(qr => 
        qr.reference_number?.toLowerCase().includes(searchLower) ||
        qr.customer_name?.toLowerCase().includes(searchLower)
      )
    } catch (error) {
      console.error('Error searching QR codes:', error)
      return []
    }
  }
}

// Export singleton instance
export const adhocQRService = new AdhocQRService()
export default adhocQRService
